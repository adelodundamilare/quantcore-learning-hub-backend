from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict
import httpx
from datetime import datetime, timedelta
import os
import asyncio
import json

app = FastAPI(title="QuantCore Trading API")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Configuration
POLYGON_API_KEY = os.getenv("POLYGON_API_KEY", "YOUR_API_KEY_HERE")
POLYGON_BASE_URL = "https://api.polygon.io"
POLYGON_WS_URL = "wss://socket.polygon.io/stocks"

# WebSocket connection manager
class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, symbol: str):
        await websocket.accept()
        if symbol not in self.active_connections:
            self.active_connections[symbol] = []
        self.active_connections[symbol].append(websocket)

    def disconnect(self, websocket: WebSocket, symbol: str):
        if symbol in self.active_connections:
            self.active_connections[symbol].remove(websocket)
            if not self.active_connections[symbol]:
                del self.active_connections[symbol]

    async def broadcast_to_symbol(self, symbol: str, message: dict):
        if symbol in self.active_connections:
            for connection in self.active_connections[symbol]:
                try:
                    await connection.send_json(message)
                except:
                    pass

manager = ConnectionManager()

# Models
class StockQuote(BaseModel):
    symbol: str
    price: float
    change: float
    change_percent: float
    timestamp: int

class StockCategory(BaseModel):
    id: int
    name: str
    symbol: str
    stocks: List[str]
    description: Optional[str] = None

class NewsArticle(BaseModel):
    id: str
    source: str
    title: str
    summary: Optional[str] = None
    url: str
    published_at: str
    image_url: Optional[str] = None
    related_symbols: List[str]
    sentiment: Optional[str] = None

class WatchList(BaseModel):
    id: str
    name: str
    stocks: List[str]
    created_at: str
    updated_at: str

class StockDetail(BaseModel):
    symbol: str
    name: str
    price: float
    change: float
    change_percent: float
    high: float
    low: float
    open: float
    volume: int
    avg_volume: int
    market_cap: Optional[float] = None
    pe_ratio: Optional[float] = None
    week_52_high: Optional[float] = None
    week_52_low: Optional[float] = None
    dividend_yield: Optional[float] = None

class CompanyInfo(BaseModel):
    name: str
    ceo: Optional[str] = None
    employees: Optional[int] = None
    headquarters: Optional[str] = None
    founded: Optional[str] = None
    description: Optional[str] = None
    industry: Optional[str] = None
    website: Optional[str] = None

class Trade(BaseModel):
    symbol: str
    action: str  # "buy" or "sell"
    quantity: int
    price: float

class Position(BaseModel):
    symbol: str
    quantity: int
    avg_price: float
    current_price: float
    total_value: float
    profit_loss: float
    profit_loss_percent: float

class Portfolio(BaseModel):
    balance: float
    total_value: float
    positions: List[Position]

class ChartDataPoint(BaseModel):
    timestamp: int
    open: float
    high: float
    low: float
    close: float
    volume: int

# Mock portfolio storage (use database in production)
user_portfolios = {
    "default": {
        "balance": 10000.00,
        "positions": []
    }
}

# Mock stock categories
stock_categories = [
    {"id": 1, "name": "Stock Category 1", "symbol": "üìä", "stocks": ["AAPL", "MSFT", "GOOGL"], "description": "Tech Giants"},
    {"id": 2, "name": "Stock Category 2", "symbol": "üî•", "stocks": ["TSLA", "NIO", "RIVN"], "description": "EV Sector"},
    {"id": 3, "name": "Stock Category 3", "symbol": "üí∞", "stocks": ["JPM", "BAC", "GS"], "description": "Banking"},
    {"id": 4, "name": "Stock Category 4", "symbol": "üè•", "stocks": ["JNJ", "PFE", "MRNA"], "description": "Healthcare"},
    {"id": 5, "name": "Stock Category 5", "symbol": "üõí", "stocks": ["AMZN", "WMT", "TGT"], "description": "Retail"},
    {"id": 6, "name": "Stock Category 6", "symbol": "üéÆ", "stocks": ["EA", "ATVI", "TTWO"], "description": "Gaming"},
    {"id": 7, "name": "Stock Category 7", "symbol": "‚úàÔ∏è", "stocks": ["BA", "LUV", "DAL"], "description": "Airlines"},
    {"id": 8, "name": "Stock Category 8", "symbol": "‚ö°", "stocks": ["ENPH", "SEDG", "FSLR"], "description": "Clean Energy"},
    {"id": 9, "name": "Stock Category 9", "symbol": "üè†", "stocks": ["ZG", "RDFN", "OPEN"], "description": "Real Estate"},
    {"id": 10, "name": "Stock Category 10", "symbol": "üçî", "stocks": ["MCD", "YUM", "CMG"], "description": "Fast Food"},
    {"id": 11, "name": "Stock Category 11", "symbol": "üí≥", "stocks": ["V", "MA", "PYPL"], "description": "Payments"},
    {"id": 12, "name": "Stock Category 12", "symbol": "üì±", "stocks": ["AAPL", "QCOM", "AVGO"], "description": "Mobile Tech"},
    {"id": 13, "name": "Stock Category 13", "symbol": "üé¨", "stocks": ["NFLX", "DIS", "PARA"], "description": "Entertainment"},
    {"id": 14, "name": "Stock Category 14", "symbol": "‚òÅÔ∏è", "stocks": ["CRM", "NOW", "WDAY"], "description": "Cloud Services"},
    {"id": 15, "name": "Stock Category 15", "symbol": "üîí", "stocks": ["CRWD", "ZS", "PANW"], "description": "Cybersecurity"},
]

# Mock user watchlists
user_watchlists = {
    "default": [
        {
            "id": "general",
            "name": "General List",
            "stocks": ["AAPL", "TSLA", "AMZN", "IBM", "NFLX", "GOOGL", "MSFT", "META"],
            "created_at": datetime.now().isoformat(),
            "updated_at": datetime.now().isoformat()
        }
    ]
}

async def get_polygon_data(endpoint: str, params: dict = None):
    """Helper function to fetch data from Polygon API"""
    async with httpx.AsyncClient(timeout=30.0) as client:
        url = f"{POLYGON_BASE_URL}{endpoint}"
        query_params = {"apiKey": POLYGON_API_KEY}
        if params:
            query_params.update(params)

        try:
            response = await client.get(url, params=query_params)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPError as e:
            raise HTTPException(status_code=500, detail=f"Error fetching data from Polygon: {str(e)}")

# ============ REST API ENDPOINTS ============

@app.get("/")
async def root():
    return {
        "message": "QuantCore Trading API",
        "version": "1.0.0",
        "endpoints": {
            "rest": [
                "/api/stocks/search/{query}",
                "/api/stocks/{symbol}/quote",
                "/api/stocks/{symbol}/details",
                "/api/stocks/{symbol}/company",
                "/api/stocks/{symbol}/chart",
                "/api/portfolio/{user_id}",
                "/api/trade",
                "/api/watchlist",
                "/api/categories",
                "/api/categories/{category_id}/stocks",
                "/api/news",
                "/api/news/{symbol}",
                "/api/lists/{user_id}",
                "/api/lists/{user_id}/{list_id}",
            ],
            "websocket": [
                "/ws/stocks/{symbol}",
                "/ws/portfolio/{user_id}"
            ]
        }
    }

@app.get("/api/stocks/search/{query}")
async def search_stocks(query: str, limit: int = 10):
    """Search for stocks by symbol or name"""
    data = await get_polygon_data(
        f"/v3/reference/tickers",
        {"search": query, "active": "true", "limit": limit}
    )

    results = data.get("results", [])
    return {
        "query": query,
        "count": len(results),
        "results": [
            {
                "symbol": r.get("ticker"),
                "name": r.get("name"),
                "market": r.get("market"),
                "type": r.get("type"),
                "currency": r.get("currency_name")
            }
            for r in results
        ]
    }

@app.get("/api/stocks/{symbol}/quote", response_model=StockQuote)
async def get_stock_quote(symbol: str):
    """Get current stock quote"""
    symbol = symbol.upper()

    # Get previous close
    prev_close_data = await get_polygon_data(f"/v2/aggs/ticker/{symbol}/prev")

    if not prev_close_data.get("results"):
        raise HTTPException(status_code=404, detail=f"Stock {symbol} not found")

    prev = prev_close_data["results"][0]

    # Try to get real-time snapshot
    try:
        snapshot_data = await get_polygon_data(f"/v2/snapshot/locale/us/markets/stocks/tickers/{symbol}")
        if snapshot_data.get("ticker"):
            ticker = snapshot_data["ticker"]
            day = ticker.get("day", {})
            current_price = day.get("c", prev["c"])

            change = current_price - prev["c"]
            change_percent = (change / prev["c"]) * 100

            return StockQuote(
                symbol=symbol,
                price=round(current_price, 2),
                change=round(change, 2),
                change_percent=round(change_percent, 2),
                timestamp=ticker.get("updated", int(datetime.now().timestamp() * 1000))
            )
    except:
        pass

    # Fallback to previous close
    change = prev["c"] - prev["o"]
    change_percent = (change / prev["o"]) * 100

    return StockQuote(
        symbol=symbol,
        price=round(prev["c"], 2),
        change=round(change, 2),
        change_percent=round(change_percent, 2),
        timestamp=prev["t"]
    )

@app.get("/api/stocks/{symbol}/details", response_model=StockDetail)
async def get_stock_details(symbol: str):
    """Get detailed stock information"""
    symbol = symbol.upper()

    # Get aggregates for OHLCV data
    today = datetime.now()
    yesterday = today - timedelta(days=7)  # Get last week to ensure data

    aggs_data = await get_polygon_data(
        f"/v2/aggs/ticker/{symbol}/range/1/day/{yesterday.strftime('%Y-%m-%d')}/{today.strftime('%Y-%m-%d')}"
    )

    if not aggs_data.get("results"):
        raise HTTPException(status_code=404, detail=f"Stock {symbol} not found")

    latest = aggs_data["results"][-1]

    # Calculate 52-week high/low
    year_ago = today - timedelta(days=365)
    year_data = await get_polygon_data(
        f"/v2/aggs/ticker/{symbol}/range/1/day/{year_ago.strftime('%Y-%m-%d')}/{today.strftime('%Y-%m-%d')}"
    )

    week_52_high = max([r["h"] for r in year_data.get("results", [])]) if year_data.get("results") else None
    week_52_low = min([r["l"] for r in year_data.get("results", [])]) if year_data.get("results") else None

    # Get ticker details
    ticker_data = await get_polygon_data(f"/v3/reference/tickers/{symbol}")
    ticker_info = ticker_data.get("results", {})

    # Calculate average volume
    recent_volumes = [r["v"] for r in aggs_data["results"][-30:]]
    avg_volume = sum(recent_volumes) // len(recent_volumes) if recent_volumes else latest["v"]

    return StockDetail(
        symbol=symbol,
        name=ticker_info.get("name", symbol),
        price=round(latest["c"], 2),
        change=round(latest["c"] - latest["o"], 2),
        change_percent=round(((latest["c"] - latest["o"]) / latest["o"]) * 100, 2),
        high=round(latest["h"], 2),
        low=round(latest["l"], 2),
        open=round(latest["o"], 2),
        volume=latest["v"],
        avg_volume=avg_volume,
        market_cap=ticker_info.get("market_cap"),
        pe_ratio=None,  # Not available in free tier
        week_52_high=round(week_52_high, 2) if week_52_high else None,
        week_52_low=round(week_52_low, 2) if week_52_low else None,
        dividend_yield=None
    )

@app.get("/api/stocks/{symbol}/company", response_model=CompanyInfo)
async def get_company_info(symbol: str):
    """Get company information"""
    symbol = symbol.upper()
    ticker_data = await get_polygon_data(f"/v3/reference/tickers/{symbol}")

    if not ticker_data.get("results"):
        raise HTTPException(status_code=404, detail=f"Company {symbol} not found")

    results = ticker_data["results"]
    address = results.get("address", {})

    return CompanyInfo(
        name=results.get("name", ""),
        ceo=None,  # Not available in Polygon free tier
        employees=None,
        headquarters=f"{address.get('city', '')}, {address.get('state', '')}".strip(", "),
        founded=None,
        description=results.get("description", ""),
        industry=results.get("sic_description", ""),
        website=results.get("homepage_url", "")
    )

@app.get("/api/stocks/{symbol}/chart")
async def get_stock_chart(
    symbol: str,
    timeframe: str = "1D",
    limit: int = 500
):
    """
    Get historical chart data
    Timeframes: 1D, 1W, 1M, 3M, 6M, YTD, 1Y, ALL
    """
    symbol = symbol.upper()
    multiplier = 1
    timespan = "minute"
    days = 1

    timeframe_map = {
        "1D": (5, "minute", 1),
        "1W": (30, "minute", 7),
        "1M": (1, "hour", 30),
        "3M": (1, "day", 90),
        "6M": (1, "day", 180),
        "YTD": (1, "day", (datetime.now() - datetime(datetime.now().year, 1, 1)).days),
        "1Y": (1, "day", 365),
        "ALL": (1, "week", 1825)
    }

    if timeframe in timeframe_map:
        multiplier, timespan, days = timeframe_map[timeframe]

    end_date = datetime.now()
    start_date = end_date - timedelta(days=days)

    data = await get_polygon_data(
        f"/v2/aggs/ticker/{symbol}/range/{multiplier}/{timespan}/{start_date.strftime('%Y-%m-%d')}/{end_date.strftime('%Y-%m-%d')}",
        {"limit": limit}
    )

    results = data.get("results", [])

    return {
        "symbol": symbol,
        "timeframe": timeframe,
        "count": len(results),
        "data": [
            ChartDataPoint(
                timestamp=r["t"],
                open=r["o"],
                high=r["h"],
                low=r["l"],
                close=r["c"],
                volume=r["v"]
            )
            for r in results
        ]
    }

@app.get("/api/portfolio/{user_id}", response_model=Portfolio)
async def get_portfolio(user_id: str = "default"):
    """Get user portfolio with current values"""
    if user_id not in user_portfolios:
        user_portfolios[user_id] = {"balance": 10000.00, "positions": []}

    portfolio = user_portfolios[user_id]
    positions = []
    total_positions_value = 0

    for pos in portfolio["positions"]:
        try:
            quote = await get_stock_quote(pos["symbol"])
            current_price = quote.price
            total_value = current_price * pos["quantity"]
            cost_basis = pos["avg_price"] * pos["quantity"]
            profit_loss = total_value - cost_basis
            profit_loss_percent = (profit_loss / cost_basis) * 100

            positions.append(Position(
                symbol=pos["symbol"],
                quantity=pos["quantity"],
                avg_price=pos["avg_price"],
                current_price=current_price,
                total_value=total_value,
                profit_loss=profit_loss,
                profit_loss_percent=profit_loss_percent
            ))
            total_positions_value += total_value
        except:
            continue

    return Portfolio(
        balance=portfolio["balance"],
        total_value=portfolio["balance"] + total_positions_value,
        positions=positions
    )

@app.post("/api/trade")
async def execute_trade(trade: Trade, user_id: str = "default"):
    """Execute a buy or sell trade"""
    if trade.action not in ["buy", "sell"]:
        raise HTTPException(status_code=400, detail="Invalid action. Use 'buy' or 'sell'")

    if user_id not in user_portfolios:
        user_portfolios[user_id] = {"balance": 10000.00, "positions": []}

    portfolio = user_portfolios[user_id]
    total_cost = trade.price * trade.quantity

    if trade.action == "buy":
        if portfolio["balance"] < total_cost:
            raise HTTPException(status_code=400, detail="Insufficient funds")

        portfolio["balance"] -= total_cost

        # Add or update position
        existing_position = next((p for p in portfolio["positions"] if p["symbol"] == trade.symbol), None)
        if existing_position:
            total_quantity = existing_position["quantity"] + trade.quantity
            total_cost_basis = (existing_position["avg_price"] * existing_position["quantity"]) + total_cost
            existing_position["quantity"] = total_quantity
            existing_position["avg_price"] = total_cost_basis / total_quantity
        else:
            portfolio["positions"].append({
                "symbol": trade.symbol,
                "quantity": trade.quantity,
                "avg_price": trade.price
            })

    elif trade.action == "sell":
        position = next((p for p in portfolio["positions"] if p["symbol"] == trade.symbol), None)
        if not position:
            raise HTTPException(status_code=400, detail=f"No position found for {trade.symbol}")
        if position["quantity"] < trade.quantity:
            raise HTTPException(status_code=400, detail=f"Insufficient shares. Available: {position['quantity']}")

        portfolio["balance"] += total_cost
        position["quantity"] -= trade.quantity

        if position["quantity"] == 0:
            portfolio["positions"].remove(position)

    return {
        "success": True,
        "message": f"{'Bought' if trade.action == 'buy' else 'Sold'} {trade.quantity} shares of {trade.symbol} at ${trade.price}",
        "portfolio": await get_portfolio(user_id)
    }

@app.get("/api/watchlist")
async def get_watchlist(symbols: str = "AAPL,TSLA,AMZN,IBM,NFLX,GOOGL,MSFT,META"):
    """Get quotes for multiple stocks with sparkline data"""
    symbol_list = [s.strip().upper() for s in symbols.split(",")]
    watchlist = []

    for symbol in symbol_list:
        try:
            # Get quote
            quote = await get_stock_quote(symbol)

            # Get mini chart data (last 50 points from 1D)
            chart = await get_stock_chart(symbol, timeframe="1D", limit=50)
            sparkline = [point.close for point in chart["data"]]

            watchlist.append({
                "symbol": quote.symbol,
                "price": quote.price,
                "change": quote.change,
                "change_percent": quote.change_percent,
                "timestamp": quote.timestamp,
                "sparkline": sparkline  # Mini chart data for rendering
            })
        except Exception as e:
            print(f"Error fetching {symbol}: {e}")
            continue

    return {"watchlist": watchlist}

# ============ STOCK CATEGORIES ENDPOINTS ============

@app.get("/api/categories")
async def get_categories():
    """Get all stock categories"""
    return {
        "categories": stock_categories,
        "count": len(stock_categories)
    }

@app.get("/api/categories/{category_id}")
async def get_category(category_id: int):
    """Get specific category details"""
    category = next((cat for cat in stock_categories if cat["id"] == category_id), None)
    if not category:
        raise HTTPException(status_code=404, detail="Category not found")
    return category

@app.get("/api/categories/{category_id}/stocks")
async def get_category_stocks(category_id: int):
    """Get all stocks in a category with their current quotes"""
    category = next((cat for cat in stock_categories if cat["id"] == category_id), None)
    if not category:
        raise HTTPException(status_code=404, detail="Category not found")

    stocks_data = []
    for symbol in category["stocks"]:
        try:
            quote = await get_stock_quote(symbol)
            stocks_data.append({
                "symbol": quote.symbol,
                "price": quote.price,
                "change": quote.change,
                "change_percent": quote.change_percent
            })
        except:
            continue

    return {
        "category": category,
        "stocks": stocks_data
    }

# ============ MARKET NEWS ENDPOINTS ============

@app.get("/api/news")
async def get_market_news(limit: int = 20, symbols: Optional[str] = None):
    """
    Get market news articles
    If symbols provided (comma-separated), filter by those symbols
    """
    params = {"limit": limit}
    if symbols:
        params["tickers"] = symbols

    try:
        news_data = await get_polygon_data("/v2/reference/news", params)

        articles = []
        for article in news_data.get("results", []):
            articles.append(NewsArticle(
                id=article.get("id", ""),
                source=article.get("publisher", {}).get("name", "Unknown"),
                title=article.get("title", ""),
                summary=article.get("description", ""),
                url=article.get("article_url", ""),
                published_at=article.get("published_utc", ""),
                image_url=article.get("image_url"),
                related_symbols=article.get("tickers", []),
                sentiment=None
            ))

        return {
            "news": articles,
            "count": len(articles)
        }
    except Exception as e:
        # Fallback to mock data if API fails
        return {
            "news": [
                {
                    "id": "1",
                    "source": "Bloomberg",
                    "title": "Netflix 'KPop Demon Hunters' Success is No Surprise",
                    "summary": "The streaming giant continues to dominate with international content.",
                    "url": "https://example.com/news/1",
                    "published_at": "8h",
                    "image_url": "https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=200",
                    "related_symbols": ["NFLX"],
                    "sentiment": "positive"
                },
                {
                    "id": "2",
                    "source": "Bloomberg",
                    "title": "Alibaba Reports Strong Quarterly Growth",
                    "summary": "Chinese e-commerce giant beats expectations with cloud services revenue.",
                    "url": "https://example.com/news/2",
                    "published_at": "8h",
                    "image_url": "https://images.unsplash.com/photo-1531973576160-7125cd663d86?w=200",
                    "related_symbols": ["BABA"],
                    "sentiment": "positive"
                },
                {
                    "id": "3",
                    "source": "Bloomberg",
                    "title": "Tech Sector Shows Resilience Amid Market Volatility",
                    "summary": "Major tech stocks maintain strong positions despite economic concerns.",
                    "url": "https://example.com/news/3",
                    "published_at": "8h",
                    "image_url": "https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=200",
                    "related_symbols": ["AAPL", "MSFT", "GOOGL"],
                    "sentiment": "neutral"
                }
            ],
            "count": 3
        }

@app.get("/api/news/{symbol}")
async def get_stock_news(symbol: str, limit: int = 10):
    """Get news articles for a specific stock"""
    symbol = symbol.upper()
    return await get_market_news(limit=limit, symbols=symbol)

# ============ USER LISTS/WATCHLISTS ENDPOINTS ============

@app.get("/api/lists/{user_id}")
async def get_user_lists(user_id: str = "default"):
    """Get all watchlists for a user"""
    if user_id not in user_watchlists:
        user_watchlists[user_id] = []

    return {
        "user_id": user_id,
        "lists": user_watchlists[user_id],
        "count": len(user_watchlists[user_id])
    }

@app.get("/api/lists/{user_id}/{list_id}")
async def get_list_details(user_id: str, list_id: str):
    """Get specific watchlist with stock quotes"""
    if user_id not in user_watchlists:
        raise HTTPException(status_code=404, detail="User not found")

    watchlist = next((wl for wl in user_watchlists[user_id] if wl["id"] == list_id), None)
    if not watchlist:
        raise HTTPException(status_code=404, detail="Watchlist not found")

    # Fetch quotes for all stocks in the list
    stocks_data = []
    for symbol in watchlist["stocks"]:
        try:
            quote = await get_stock_quote(symbol)
            chart = await get_stock_chart(symbol, timeframe="1D", limit=50)
            sparkline = [point.close for point in chart["data"]]

            stocks_data.append({
                "symbol": quote.symbol,
                "price": quote.price,
                "change": quote.change,
                "change_percent": quote.change_percent,
                "sparkline": sparkline
            })
        except:
            continue

    return {
        "list": watchlist,
        "stocks": stocks_data
    }

@app.post("/api/lists/{user_id}")
async def create_watchlist(user_id: str, name: str, stocks: List[str] = []):
    """Create a new watchlist"""
    if user_id not in user_watchlists:
        user_watchlists[user_id] = []

    new_list = {
        "id": f"list_{len(user_watchlists[user_id]) + 1}",
        "name": name,
        "stocks": [s.upper() for s in stocks],
        "created_at": datetime.now().isoformat(),
        "updated_at": datetime.now().isoformat()
    }

    user_watchlists[user_id].append(new_list)

    return {
        "success": True,
        "list": new_list
    }

@app.put("/api/lists/{user_id}/{list_id}")
async def update_watchlist(user_id: str, list_id: str, name: Optional[str] = None, stocks: Optional[List[str]] = None):
    """Update a watchlist"""
    if user_id not in user_watchlists:
        raise HTTPException(status_code=404, detail="User not found")

    watchlist = next((wl for wl in user_watchlists[user_id] if wl["id"] == list_id), None)
    if not watchlist:
        raise HTTPException(status_code=404, detail="Watchlist not found")

    if name:
        watchlist["name"] = name
    if stocks is not None:
        watchlist["stocks"] = [s.upper() for s in stocks]

    watchlist["updated_at"] = datetime.now().isoformat()

    return {
        "success": True,
        "list": watchlist
    }

@app.delete("/api/lists/{user_id}/{list_id}")
async def delete_watchlist(user_id: str, list_id: str):
    """Delete a watchlist"""
    if user_id not in user_watchlists:
        raise HTTPException(status_code=404, detail="User not found")

    watchlist = next((wl for wl in user_watchlists[user_id] if wl["id"] == list_id), None)
    if not watchlist:
        raise HTTPException(status_code=404, detail="Watchlist not found")

    user_watchlists[user_id].remove(watchlist)

    return {
        "success": True,
        "message": "Watchlist deleted"
    }

@app.post("/api/lists/{user_id}/{list_id}/stocks/{symbol}")
async def add_stock_to_list(user_id: str, list_id: str, symbol: str):
    """Add a stock to a watchlist"""
    if user_id not in user_watchlists:
        raise HTTPException(status_code=404, detail="User not found")

    watchlist = next((wl for wl in user_watchlists[user_id] if wl["id"] == list_id), None)
    if not watchlist:
        raise HTTPException(status_code=404, detail="Watchlist not found")

    symbol = symbol.upper()
    if symbol not in watchlist["stocks"]:
        watchlist["stocks"].append(symbol)
        watchlist["updated_at"] = datetime.now().isoformat()

    return {
        "success": True,
        "list": watchlist
    }

@app.delete("/api/lists/{user_id}/{list_id}/stocks/{symbol}")
async def remove_stock_from_list(user_id: str, list_id: str, symbol: str):
    """Remove a stock from a watchlist"""
    if user_id not in user_watchlists:
        raise HTTPException(status_code=404, detail="User not found")

    watchlist = next((wl for wl in user_watchlists[user_id] if wl["id"] == list_id), None)
    if not watchlist:
        raise HTTPException(status_code=404, detail="Watchlist not found")

    symbol = symbol.upper()
    if symbol in watchlist["stocks"]:
        watchlist["stocks"].remove(symbol)
        watchlist["updated_at"] = datetime.now().isoformat()

    return {
        "success": True,
        "list": watchlist
    }

# ============ WEBSOCKET ENDPOINT ============

@app.websocket("/ws/stocks/{symbol}")
async def websocket_endpoint(websocket: WebSocket, symbol: str):
    """
    WebSocket endpoint for real-time stock data
    Sends updates every 5 seconds (can be adjusted)
    """
    symbol = symbol.upper()
    await manager.connect(websocket, symbol)

    try:
        while True:
            try:
                # Fetch current quote
                quote = await get_stock_quote(symbol)

                # Send to client
                await websocket.send_json({
                    "type": "quote",
                    "data": {
                        "symbol": quote.symbol,
                        "price": quote.price,
                        "change": quote.change,
                        "change_percent": quote.change_percent,
                        "timestamp": quote.timestamp
                    }
                })

                # Wait before next update (5 seconds)
                await asyncio.sleep(5)

            except Exception as e:
                await websocket.send_json({
                    "type": "error",
                    "message": str(e)
                })
                await asyncio.sleep(5)

    except WebSocketDisconnect:
        manager.disconnect(websocket, symbol)

@app.websocket("/ws/portfolio/{user_id}")
async def portfolio_websocket(websocket: WebSocket, user_id: str = "default"):
    """
    WebSocket endpoint for real-time portfolio updates
    """
    await websocket.accept()

    try:
        while True:
            try:
                # Fetch current portfolio
                portfolio = await get_portfolio(user_id)

                # Send to client
                await websocket.send_json({
                    "type": "portfolio",
                    "data": portfolio.dict()
                })

                # Wait before next update (10 seconds)
                await asyncio.sleep(10)

            except Exception as e:
                await websocket.send_json({
                    "type": "error",
                    "message": str(e)
                })
                await asyncio.sleep(10)

    except WebSocketDisconnect:
        pass

# Health check
@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)